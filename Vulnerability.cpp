#include "Vulnerability.h"

//--------------------------------------------------------------
Vulnerability::Vulnerability(string spr_filename) : Shutdown(spr_filename){}
Vulnerability::~Vulnerability(){}

//--------------------------------------------------------------
void Vulnerability::calculateVulnerability()
{

	int nPres = presIndex.size();
	int nPool = poolIndex.size();

	// if there is only one pres or pool in overall it cannot be closed
	int doNotClose = -2;
	if(nPres == 1 && nPool == 0)
		doNotClose = edges[presIndex[0]]->segment;
	else if(nPres == 0 && nPool == 1)
		doNotClose = edges[poolIndex[0]]->segment;

	// calculating how much pipe lengths are in each segment
	vector<double> Li(numberSegment,0.); // in meter
	vector<double> li(numberSegment,0.); // dimensionless
	relativePipeLength.resize(numberSegment,0.);
	double sumL=0.; // in meter

	for(int i=0; i<edges.size(); i++)
	{
      if(edges[i]->typeCode == 1 || edges[i]->typeCode == 0) // pipe, pipeCV
      {
      	double L = edges[i]->getDoubleProperty("length");
			Li[edges[i]->segment] += L;
			sumL += L;
      }
	}
	for(int i=0; i<numberSegment; i++)
	{
		li[i] = Li[i] / sumL;
		relativePipeLength[i] = li[i];
	}

	// calculating how much water is not provided in case of i-th segment loss
	vector<double> Bi(numberSegment,0.); // in m3/s
	vector<double> bi(numberSegment,0.); // dimensionless
	relativeDemandLoss.resize(numberSegment,0.);
	double sumd=0.; // in m3/s

	for(int i=0; i<numberNodes; i++)
	{
		sumd += nodes[i]->demand;
	}

	for(int i=0; i<numberSegment; i++)
	{
		if(i != doNotClose)
		{
			openEverything();
			closeSegment(i);

			isPressureDemand = true;
			solveSystem();

			double b = 0.;
			for(int j=0; j<numberNodes; j++)
			{
				b += nodes[j]->getProperty("consumption");
			}

			Bi[i] = sumd - b;
			bi[i] = Bi[i] / sumd;
			relativeDemandLoss[i] = bi[i];
		}
		//TODO mi van ha minden zarva van?
		// valójában bi = 1 :(, ezt nem igazán vettem elsőre figyelembe azt hiszem :'(
      printf("\n j / nSeg: %3i / %-3i", i, numberSegment);
	}

	// calculate local vulnerability
	localGamma.resize(numberSegment,0.);
	globalGamma = 0.;
	for(int i=0; i<numberSegment; i++)
	{
		localGamma[i] = bi[i] * li[i];
		globalGamma += localGamma[i];
	}

}




