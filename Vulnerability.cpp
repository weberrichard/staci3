#include "Vulnerability.h"

//--------------------------------------------------------------
Vulnerability::Vulnerability(string spr_filename) : Shutdown(spr_filename){}
Vulnerability::~Vulnerability(){}

//--------------------------------------------------------------
void Vulnerability::calculateVulnerability()
{
	calculateVulnerability(relativePipeLength);
}

//--------------------------------------------------------------
void Vulnerability::calculateVulnerability(vector<double> failureRate)
{

	int nPres = presIndex.size();
	int nPool = poolIndex.size();

	// if there is only one pres or pool in overall it cannot be closed
	int doNotClose = -2;
	if(nPres == 1 && nPool == 0)
		doNotClose = edges[presIndex[0]]->segment;
	else if(nPres == 0 && nPool == 1)
		doNotClose = edges[poolIndex[0]]->segment;

	// calculating how much water is not provided in case of i-th segment loss
	vector<double> Bi(numberSegment,0.); // in m3/s
	vector<double> bi(numberSegment,0.); // dimensionless
	relativeDemandLoss.resize(numberSegment,0.);
	double sumd=0.; // in m3/s

	for(int i=0; i<numberNodes; i++)
	{
		sumd += nodes[i]->demand;
	}

	for(int i=0; i<numberSegment; i++)
	{
		if(i != doNotClose)
		{
			openEverything();
			closeSegment(i);

			isPressureDemand = true;
			solveSystem();

			double b = 0.;
			for(int j=0; j<numberNodes; j++)
			{
				b += nodes[j]->getProperty("consumption");
			}

			Bi[i] = sumd - b;
			bi[i] = Bi[i] / sumd;
			relativeDemandLoss[i] = bi[i];
		}
		else
		{
			bi[i] = 1.;
			relativeDemandLoss[i] = 1.;
		}
		//if(printLevel>1)
	   printf("\n j / nSeg: %3i / %-3i", i, numberSegment-1);
	}

	vector<double> li = failureRate;

	// calculate local vulnerability
	localGamma.resize(numberSegment,0.);
	globalGamma = 0.;
	for(int i=0; i<numberSegment; i++)
	{
		localGamma[i] = bi[i] * li[i];
		globalGamma += localGamma[i];
	}

	// reopen everything
	openEverything();
}



