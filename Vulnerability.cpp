#include "Vulnerability.h"

//--------------------------------------------------------------
Vulnerability::Vulnerability(string spr_filename) : Shutdown(spr_filename){}
Vulnerability::~Vulnerability(){}

//--------------------------------------------------------------
void Vulnerability::calculateVulnerability()
{
	calculateVulnerability(relativePipeLength);
}

//--------------------------------------------------------------
void Vulnerability::calculateVulnerability(vector<double> failureRate)
{
	int nPres = presIndex.size();
	int nPool = poolIndex.size();

	// if there is only one pres or pool in overall it cannot be closed
	int doNotClose = -2;
	if(nPres == 1 && nPool == 0)
		doNotClose = edges[presIndex[0]]->segment;
	else if(nPres == 0 && nPool == 1)
		doNotClose = edges[poolIndex[0]]->segment;

	// calculating how much water is not provided in case of i-th segment loss
	vector<double> Bi(numberSegment,0.); // in m3/s
	vector<double> bi(numberSegment,0.); // dimensionless
	relativeDemandLoss.resize(numberSegment,0.);
	double sumd=0.; // in m3/s

	for(int i=0; i<numberNodes; i++)
	{
		sumd += nodes[i]->demand;
	}

	for(int i=0; i<numberSegment; i++)
	{
		if(i != doNotClose)
		{
			openEverything();
			closeSegment(i);

			isPressureDemand = true;
			solveSystem();

			double b = 0.;
			for(int j=0; j<numberNodes; j++)
			{
				b += nodes[j]->getProperty("consumption");
			}

			Bi[i] = sumd - b;
			bi[i] = Bi[i] / sumd;
			relativeDemandLoss[i] = bi[i];
		}
		else
		{
			bi[i] = 1.;
			relativeDemandLoss[i] = 1.;
		}
		// if(printLevel>1)
	  		printf("\n j / nSeg: %3i / %-3i", i, numberSegment-1);
	}

	vector<double> li = failureRate;

	// calculate local vulnerability
	localGamma.resize(numberSegment,0.);
	globalGamma = 0.;
	for(int i=0; i<numberSegment; i++)
	{
		localGamma[i] = bi[i] * li[i];
		globalGamma += localGamma[i];
	}

	// reopen everything
	openEverything();
}

//--------------------------------------------------------------
void Vulnerability::calculateVulnerabilityApprox()
{
	calculateVulnerabilityApprox(relativePipeLength);
}

//--------------------------------------------------------------
void Vulnerability::calculateVulnerabilitySeries()
{
	int nPres = presIndex.size();
	int nPool = poolIndex.size();

	// if there is only one pres or pool in overall it cannot be closed
	int doNotClose = -2;
	if(nPres == 1 && nPool == 0)
		doNotClose = edges[presIndex[0]]->segment;
	else if(nPres == 0 && nPool == 1)
		doNotClose = edges[poolIndex[0]]->segment;

	// calculating how much water is not provided in case of i-th segment loss
	vector<double> Bi(numberSegment,0.); // in m3/s
	vector<double> bi(numberSegment,0.); // dimensionless
	relativeDemandLoss.resize(numberSegment,0.);

	for(int i=30; i<numberSegment; i++)
	{
		if(i != doNotClose)
		{
			openEverything();
			closeSegment(i);

			isPressureDemand = true;
			seriesSolve();

			double b = 0.;
			double sumd=0.;
			for(int j=0; j<numberNodes; j++)
			{
				vector<double> v1 = nodes[j]->vectorConsumption;
				vector<double> v2 = nodes[j]->vectorDemand;
				for(int k=0; k<v1.size(); k++)
				{
					b += v1[k];
					sumd += v2[k];
				}
			}

			Bi[i] = sumd - b;
			bi[i] = Bi[i] / sumd;
			relativeDemandLoss[i] = bi[i];
		}
		else
		{
			bi[i] = 1.;
			relativeDemandLoss[i] = 1.;
		}
		//if(printLevel>1)
	   printf("\n j / nSeg: %3i / %-3i", i, numberSegment-1);
	}

	vector<double> li = relativePipeLength;

	// calculate local vulnerability
	localGamma.resize(numberSegment,0.);
	globalGamma = 0.;
	for(int i=0; i<numberSegment; i++)
	{
		localGamma[i] = bi[i] * li[i];
		globalGamma += localGamma[i];
	}

	// reopen everything
	openEverything();
}

//--------------------------------------------------------------
void Vulnerability::calculateVulnerabilityApprox(vector<double> failureRate)
{
	// calculating approximately how much water is not provided in case of i-th segment loss
	vector<double> Bias(numberSegment,0.); // with unit
	vector<double> Bial(numberSegment,0.); // with unit
	vector<double> Biad(numberSegment,0.); // with unit
	vector<double> bias(numberSegment,0.); // dimensionless
	vector<double> bial(numberSegment,0.); // dimensionless
	vector<double> biad(numberSegment,0.); // dimensionless
	relativeSegmentLoss.resize(numberSegment,0.);
	relativeLengthLoss.resize(numberSegment,0.);
	relativeDemandLossApprox.resize(numberSegment,0.);

	double sumd=0.; // in m3/s
	for(int i=0; i<numberNodes; i++)
	{
		sumd += nodes[i]->demand;
	}

	double suml=0.; // m
	for(int i=0; i<numberEdges; i++)
	{
		int tc = edges[i]->typeCode;
		if(tc == 1 || tc == 0) // Pipe and pipe with CV
		{
			suml += edges[i]->getDoubleProperty("length");
		}
	}

	for(int i=0; i<numberSegment; i++)
	{
		openEverything();
		closeSegment(i);

		vector<int> cs;
		for(int j=0; j<numberNodes; j++)
		{
			if(nodes[j]->status<1)
			{
				cs.push_back(nodes[j]->segment);
				Biad[i] += nodes[j]->demand;
			}
		}
		cs = unique(cs);
		Bias[i] = cs.size();

		for(int j=0; j<numberEdges; j++)
		{
			int tc = edges[j]->typeCode;
			int s = edges[j]->status;
			if(s<1 && (tc==1 || tc==0))
			{
				Bial[i] += edges[j]->getDoubleProperty("length");
			}
		}

		bias[i] = Bias[i]/numberSegment;
		bial[i] = Bial[i]/suml;
		biad[i] = Biad[i]/sumd;

		relativeSegmentLoss[i] = bias[i];
		relativeLengthLoss[i] = bial[i];
		relativeDemandLossApprox[i] = biad[i];
	}

	vector<double> li = failureRate;

	// calculate local vulnerability
	localGammaSegment.resize(numberSegment,0.);
	localGammaLength.resize(numberSegment,0.);
	localGammaDemand.resize(numberSegment,0.);
	globalGammaSegment = 0.;
	globalGammaLength = 0.;
	globalGammaDemand = 0.;
	for(int i=0; i<numberSegment; i++)
	{
		localGammaSegment[i] = bias[i] * li[i];
		localGammaLength[i] = bial[i] * li[i];
		localGammaDemand[i] = biad[i] * li[i];
		globalGammaSegment += localGammaSegment[i];
		globalGammaLength += localGammaLength[i];
		globalGammaDemand += localGammaDemand[i];
	}

	// reopen everything
	openEverything();
}

//--------------------------------------------------------------
void Vulnerability::calculateBackupVulnerability()
{
	backupGamma.resize(numberSegment,0.);

	int nPres = presIndex.size();
	int nPool = poolIndex.size();

	// if there is only one pres or pool in overall it cannot be closed
	int doNotClose = -2;
	if(nPres == 1 && nPool == 0)
		doNotClose = edges[presIndex[0]]->segment;
	else if(nPres == 0 && nPool == 1)
		doNotClose = edges[poolIndex[0]]->segment;

	for(int I=0; I<numberSegment; I++)
	{
		// calculating how much water is not provided in case of i-th segment loss
		vector<double> Bi(numberSegment,0.); // in m3/s
		vector<double> bi(numberSegment,0.); // dimensionless
		relativeDemandLoss.resize(numberSegment,0.);
		double sumd=0.; // in m3/s

		for(int i=0; i<numberNodes; i++)
		{
			if(i != I)
			{
				sumd += nodes[i]->demand;
			}
		}

		for(int i=0; i<numberSegment; i++)
		{
			if(i != doNotClose && i != I)
			{
				openEverything();
				closeSegment(i);
				closeSegment(I);

				isPressureDemand = true;
				solveSystem();

				double b = 0.;
				for(int j=0; j<numberNodes; j++)
				{
					if(j != I)
					{
						b += nodes[j]->getProperty("consumption");
					}
				}

				Bi[i] = sumd - b;
				bi[i] = Bi[i] / sumd;
				relativeDemandLoss[i] = bi[i];
			}
			else
			{
				bi[i] = 1.;
				relativeDemandLoss[i] = 1.;
			}
			//if(printLevel>1)
		  		printf("\n I / j / nSeg: %3i / %3i / %-3i", I, i, numberSegment-1);
		}

		vector<double> li = relativePipeLength;

		// calculate local vulnerability
		localGamma.resize(numberSegment,0.);
		globalGamma = 0.;
		for(int i=0; i<numberSegment; i++)
		{
			if(i != I)
			{
				localGamma[i] = bi[i] * li[i];
				globalGamma += localGamma[i];
			}
		}

		backupGamma[I] = globalGamma;
	}

	// reopen everything
	openEverything();
}